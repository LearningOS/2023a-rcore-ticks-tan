## 功能实现

`sys_task_info`  函数需要对传入的 `TaskInfo` 内容赋值，
其中任务状态由于是当前正在运行任务，所以直接赋值为 `TaskStatus::Running`。

系统调用次数和任务运行时间无法直接赋值，需要在内核任务控制块中包含额外字段记录。

我先实现了任务运行时间的获取，要求的是返回距离任务开始运行时间，
可以在进行任务切换和运行第一个任务函数中添加一个时间点表示任务开始运行时间。
通过系统调用时时间减去任务开始运行时间得到运行时间间隔。

系统调用次数我直接使用了数组形式记录， 并在每次具体调用系统调用实现之前对当前任务系统调用次数进行计数。

## 问答题

1. 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令， 访问 S 态寄存器后会报错。 
    请同学们可以自行测试这些内容 (运行 Rust 三个 bad 测例 (ch2b_bad_*.rs) ， 
    注意在编译时至少需要指定 LOG=ERROR 才能观察到内核的报错信息) ， 
    描述程序出错行为，同时注意注明你使用的 sbi 及其版本。

   答：
2. 深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:
   1. L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。
       
      答：刚进入 `__restore` 时，`a0` 寄存器代表内核上下文，两种用途是 **第一次切入用户态代码执行** 和 **用户态代码中断进入内核处理后切换栈并返回用户态** 。
   2. L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。
      ```asm
      ld t0, 32*8(sp) ;; 加载sstatus
      ld t1, 33*8(sp) ;; 加载 sepc
      ld t2, 2*8(sp)  ;; 加载 sscratch
      csrw sstatus, t0 ;; 设置 sstatus，可以设置CPU处于哪个模式 （U/P）
      csrw sepc, t1    ;; 设置 sepc，结尾 sret 会返回到该寄存器地址处执行，确保回到用户进入中断的下一条地址
      csrw sscratch, t2 ;; 设置 sscratch，保存了对应任务的内核栈
      ```
   3. L50-L56：为何跳过了 x2 和 x4？
      ```asm
      ld x1, 1*8(sp)
      ld x3, 3*8(sp)
      .set n, 5
      .rept 27
          LOAD_GP %n
          .set n, n+1
      .endr
      ```
      答：`x2` 是栈指针寄存器，会在后面从`sscratch` 恢复，x4是tp,应用程序目前没有使用到。
   4. L60：该指令之后，sp 和 sscratch 中的值分别有什么意义？
      ```asm
      csrrw sp, sscratch, sp
      ```
      答：之后 `sp` 重新指向用户栈，中断返回后程序可以正确使用栈，而 `sscratch` 重新回到进入中断前的状态，指向内核栈。
   5. __restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？ 
      
      答：状态转换指令为 `sret` ，该指令可以返回到 `sepc` 处继续执行，其中我们通过设置了 `sstatus` 寄存器中 SPP 字段
      切换了CPU特权级。
   6. L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？
      ```asm
      csrrw sp, sscratch, sp
      ```
      答：交换了 `sstratch` 和 `sp` ，之后 `sp` 指向内核栈，`sstratch` 执行用户栈。
   7. 从 U 态进入 S 态是哪一条指令发生的？
      
      答：通过 `ecall` 指令完成，由于我们代码中设置了 `stvec` 为直接模式，且指向我们的处理函数：`__alltraps` ，完成中断处理。

## 其他

本次实验设计还是比较简单的，主要在与理解系统调用和任务切换流程，并添加了一个新的系统调用，
为之后我们加入自己的系统调用打下基础。

## 荣誉准则：

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：


2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：


3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。